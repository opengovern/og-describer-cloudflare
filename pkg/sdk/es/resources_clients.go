// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	//"encoding/json"
	//"fmt"
	//cloudflareDescriber "github.com/opengovern/og-describer-cloudflare/provider/describer"
	cloudflare "github.com/opengovern/og-describer-cloudflare/provider/model"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: AccessApplication =============================

type AccessApplication struct {
	ResourceID      string                                  `json:"resource_id"`
	PlatformID      string                                  `json:"platform_id"`
	Description     cloudflare.AccessApplicationDescription `json:"description"`
	Metadata        cloudflare.Metadata                     `json:"metadata"`
	DescribedBy     string                                  `json:"described_by"`
	ResourceType    string                                  `json:"resource_type"`
	IntegrationType string                                  `json:"integration_type"`
	IntegrationID   string                                  `json:"integration_id"`
}

type AccessApplicationHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  AccessApplication `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type AccessApplicationHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []AccessApplicationHit `json:"hits"`
}

type AccessApplicationSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  AccessApplicationHits `json:"hits"`
}

type AccessApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccessApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (AccessApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_access_application", filters, limit)
	if err != nil {
		return AccessApplicationPaginator{}, err
	}

	p := AccessApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccessApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccessApplicationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccessApplicationPaginator) NextPage(ctx context.Context) ([]AccessApplication, error) {
	var response AccessApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccessApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccessApplicationFilters = map[string]string{
	"account_id":   "ID",
	"account_name": "Name",
}

func ListAccessApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccessApplication")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccessApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccessApplicationFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication NewAccessApplicationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccessApplication paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccessApplicationFilters = map[string]string{
	"account_id":   "ID",
	"account_name": "Name",
}

func GetAccessApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccessApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccessApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccessApplicationFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccessApplication =============================

// ==========================  START: AccessGroup =============================

type AccessGroup struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     cloudflare.AccessGroupDescription `json:"description"`
	Metadata        cloudflare.Metadata               `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type AccessGroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AccessGroup   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccessGroupHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AccessGroupHit  `json:"hits"`
}

type AccessGroupSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  AccessGroupHits `json:"hits"`
}

type AccessGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccessGroupPaginator(filters []essdk.BoolFilter, limit *int64) (AccessGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_access_group", filters, limit)
	if err != nil {
		return AccessGroupPaginator{}, err
	}

	p := AccessGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccessGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccessGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccessGroupPaginator) NextPage(ctx context.Context) ([]AccessGroup, error) {
	var response AccessGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccessGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccessGroupFilters = map[string]string{
	"account_id":   "ID",
	"account_name": "Name",
}

func ListAccessGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccessGroup")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccessGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccessGroupFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup NewAccessGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccessGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccessGroupFilters = map[string]string{
	"account_id":   "ID",
	"account_name": "Name",
}

func GetAccessGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccessGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccessGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccessGroupFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccessGroup =============================

// ==========================  START: AccessPolicy =============================

type AccessPolicy struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     cloudflare.AccessPolicyDescription `json:"description"`
	Metadata        cloudflare.Metadata                `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type AccessPolicyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AccessPolicy  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccessPolicyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AccessPolicyHit `json:"hits"`
}

type AccessPolicySearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  AccessPolicyHits `json:"hits"`
}

type AccessPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccessPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (AccessPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_access_policy", filters, limit)
	if err != nil {
		return AccessPolicyPaginator{}, err
	}

	p := AccessPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccessPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccessPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccessPolicyPaginator) NextPage(ctx context.Context) ([]AccessPolicy, error) {
	var response AccessPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccessPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccessPolicyFilters = map[string]string{
	"application_id":   "ID",
	"application_name": "Name",
}

func ListAccessPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccessPolicy")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccessPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccessPolicyFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy NewAccessPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccessPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccessPolicyFilters = map[string]string{
	"application_id":   "ID",
	"application_name": "Name",
}

func GetAccessPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccessPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccessPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccessPolicyFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccessPolicy =============================

// ==========================  START: Account =============================

type Account struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     cloudflare.AccountDescription `json:"description"`
	Metadata        cloudflare.Metadata           `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type AccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Account       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccountHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AccountHit      `json:"hits"`
}

type AccountSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  AccountHits `json:"hits"`
}

type AccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountPaginator(filters []essdk.BoolFilter, limit *int64) (AccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_account", filters, limit)
	if err != nil {
		return AccountPaginator{}, err
	}

	p := AccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccountPaginator) NextPage(ctx context.Context) ([]Account, error) {
	var response AccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Account
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountFilters = map[string]string{}

func ListAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccountFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccountFilters = map[string]string{}

func GetAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccountFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Account =============================

// ==========================  START: DNSRecord =============================

type DNSRecord struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     cloudflare.DNSRecordDescription `json:"description"`
	Metadata        cloudflare.Metadata             `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type DNSRecordHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DNSRecord     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DNSRecordHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DNSRecordHit    `json:"hits"`
}

type DNSRecordSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  DNSRecordHits `json:"hits"`
}

type DNSRecordPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDNSRecordPaginator(filters []essdk.BoolFilter, limit *int64) (DNSRecordPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_dnsrecord", filters, limit)
	if err != nil {
		return DNSRecordPaginator{}, err
	}

	p := DNSRecordPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DNSRecordPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DNSRecordPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DNSRecordPaginator) NextPage(ctx context.Context) ([]DNSRecord, error) {
	var response DNSRecordSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DNSRecord
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDNSRecordFilters = map[string]string{}

func ListDNSRecord(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDNSRecord")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDNSRecordPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDNSRecordFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord NewDNSRecordPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDNSRecord paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDNSRecordFilters = map[string]string{}

func GetDNSRecord(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDNSRecord")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDNSRecordPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDNSRecordFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DNSRecord =============================

// ==========================  START: FireWallRule =============================

type FireWallRule struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     cloudflare.FireWallRuleDescription `json:"description"`
	Metadata        cloudflare.Metadata                `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type FireWallRuleHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  FireWallRule  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FireWallRuleHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FireWallRuleHit `json:"hits"`
}

type FireWallRuleSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  FireWallRuleHits `json:"hits"`
}

type FireWallRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFireWallRulePaginator(filters []essdk.BoolFilter, limit *int64) (FireWallRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_firewall_rule", filters, limit)
	if err != nil {
		return FireWallRulePaginator{}, err
	}

	p := FireWallRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FireWallRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FireWallRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FireWallRulePaginator) NextPage(ctx context.Context) ([]FireWallRule, error) {
	var response FireWallRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FireWallRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFireWallRuleFilters = map[string]string{
	"id":      "ID",
	"title":   "ID",
	"zone_id": "ZoneID",
}

func ListFireWallRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFireWallRule")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFireWallRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listFireWallRuleFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule NewFireWallRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFireWallRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFireWallRuleFilters = map[string]string{
	"id":      "ID",
	"title":   "ID",
	"zone_id": "ZoneID",
}

func GetFireWallRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFireWallRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFireWallRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getFireWallRuleFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: FireWallRule =============================

// ==========================  START: LoadBalancer =============================

type LoadBalancer struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     cloudflare.LoadBalancerDescription `json:"description"`
	Metadata        cloudflare.Metadata                `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type LoadBalancerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LoadBalancer  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LoadBalancerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LoadBalancerHit `json:"hits"`
}

type LoadBalancerSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  LoadBalancerHits `json:"hits"`
}

type LoadBalancerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerPaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_loadbalancer", filters, limit)
	if err != nil {
		return LoadBalancerPaginator{}, err
	}

	p := LoadBalancerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LoadBalancerPaginator) NextPage(ctx context.Context) ([]LoadBalancer, error) {
	var response LoadBalancerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerFilters = map[string]string{
	"zone_id":   "ID",
	"zone_name": "Name",
}

func ListLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer NewSelfClientCached", "error", err)
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyAccountID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLoadBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLoadBalancerFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer NewLoadBalancerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLoadBalancer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLoadBalancerFilters = map[string]string{
	"zone_id":   "ID",
	"zone_name": "Name",
}

func GetLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	accountId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyAccountID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLoadBalancerFilters, "cloudflare", accountId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LoadBalancer =============================
