// Code is generated by go generate. DO NOT EDIT.
package opengovernance

import (
	"context"
	cloudflare "github.com/opengovern/og-describer-cloudflare/discovery/provider"
	essdk "github.com/opengovern/og-util/pkg/opengovernance-es-sdk"
	steampipesdk "github.com/opengovern/og-util/pkg/steampipe"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"runtime"
)

type Client struct {
	essdk.Client
}

// ==========================  START: AccessApplication =============================

type AccessApplication struct {
	ResourceID      string                                  `json:"resource_id"`
	PlatformID      string                                  `json:"platform_id"`
	Description     cloudflare.AccessApplicationDescription `json:"Description"`
	Metadata        cloudflare.Metadata                     `json:"metadata"`
	DescribedBy     string                                  `json:"described_by"`
	ResourceType    string                                  `json:"resource_type"`
	IntegrationType string                                  `json:"integration_type"`
	IntegrationID   string                                  `json:"integration_id"`
}

type AccessApplicationHit struct {
	ID      string            `json:"_id"`
	Score   float64           `json:"_score"`
	Index   string            `json:"_index"`
	Type    string            `json:"_type"`
	Version int64             `json:"_version,omitempty"`
	Source  AccessApplication `json:"_source"`
	Sort    []interface{}     `json:"sort"`
}

type AccessApplicationHits struct {
	Total essdk.SearchTotal      `json:"total"`
	Hits  []AccessApplicationHit `json:"hits"`
}

type AccessApplicationSearchResponse struct {
	PitID string                `json:"pit_id"`
	Hits  AccessApplicationHits `json:"hits"`
}

type AccessApplicationPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccessApplicationPaginator(filters []essdk.BoolFilter, limit *int64) (AccessApplicationPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_access_application", filters, limit)
	if err != nil {
		return AccessApplicationPaginator{}, err
	}

	p := AccessApplicationPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccessApplicationPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccessApplicationPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccessApplicationPaginator) NextPage(ctx context.Context) ([]AccessApplication, error) {
	var response AccessApplicationSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccessApplication
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccessApplicationFilters = map[string]string{
	"account_id":                "Description.AccountID",
	"account_name":              "Description.AccountName",
	"allowed_idps":              "Description.AllowedIDPs",
	"aud":                       "Description.AUD",
	"auto_redirect_to_identity": "Description.AutoRedirectToIdentity",
	"cors_headers":              "Description.CORSHeaders",
	"created_at":                "Description.CreatedAt",
	"custom_deny_message":       "Description.CustomDenyMessage",
	"custom_deny_url":           "Description.CustomDenyURL",
	"domain":                    "Description.Domain",
	"enable_binding_cookie":     "Description.EnableBindingCookie",
	"id":                        "Description.ID",
	"name":                      "Description.Name",
	"session_duration":          "Description.SessionDuration",
	"updated_at":                "Description.UpdatedAt",
}

func ListAccessApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccessApplication")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccessApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccessApplicationFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessApplication NewAccessApplicationPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccessApplication paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccessApplicationFilters = map[string]string{
	"account_id":                "Description.AccountID",
	"account_name":              "Description.AccountName",
	"allowed_idps":              "Description.AllowedIDPs",
	"aud":                       "Description.AUD",
	"auto_redirect_to_identity": "Description.AutoRedirectToIdentity",
	"cors_headers":              "Description.CORSHeaders",
	"created_at":                "Description.CreatedAt",
	"custom_deny_message":       "Description.CustomDenyMessage",
	"custom_deny_url":           "Description.CustomDenyURL",
	"domain":                    "Description.Domain",
	"enable_binding_cookie":     "Description.EnableBindingCookie",
	"id":                        "Description.ID",
	"name":                      "Description.Name",
	"session_duration":          "Description.SessionDuration",
	"updated_at":                "Description.UpdatedAt",
}

func GetAccessApplication(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccessApplication")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccessApplicationPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccessApplicationFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccessApplication =============================

// ==========================  START: AccessGroup =============================

type AccessGroup struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     cloudflare.AccessGroupDescription `json:"Description"`
	Metadata        cloudflare.Metadata               `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type AccessGroupHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AccessGroup   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccessGroupHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AccessGroupHit  `json:"hits"`
}

type AccessGroupSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  AccessGroupHits `json:"hits"`
}

type AccessGroupPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccessGroupPaginator(filters []essdk.BoolFilter, limit *int64) (AccessGroupPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_access_group", filters, limit)
	if err != nil {
		return AccessGroupPaginator{}, err
	}

	p := AccessGroupPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccessGroupPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccessGroupPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccessGroupPaginator) NextPage(ctx context.Context) ([]AccessGroup, error) {
	var response AccessGroupSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccessGroup
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccessGroupFilters = map[string]string{
	"account_id":   "Description.AccountID",
	"account_name": "Description.AccountName",
	"created_at":   "Description.CreatedAt",
	"exclude":      "Description.Exclude",
	"id":           "Description.ID",
	"include":      "Description.Include",
	"name":         "Description.Name",
	"require":      "Description.Require",
	"updated_at":   "Description.UpdatedAt",
}

func ListAccessGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccessGroup")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccessGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccessGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessGroup NewAccessGroupPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccessGroup paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccessGroupFilters = map[string]string{
	"account_id":   "Description.AccountID",
	"account_name": "Description.AccountName",
	"created_at":   "Description.CreatedAt",
	"exclude":      "Description.Exclude",
	"id":           "Description.ID",
	"include":      "Description.Include",
	"name":         "Description.Name",
	"require":      "Description.Require",
	"updated_at":   "Description.UpdatedAt",
}

func GetAccessGroup(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccessGroup")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccessGroupPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccessGroupFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccessGroup =============================

// ==========================  START: AccessPolicy =============================

type AccessPolicy struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     cloudflare.AccessPolicyDescription `json:"Description"`
	Metadata        cloudflare.Metadata                `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type AccessPolicyHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AccessPolicy  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccessPolicyHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AccessPolicyHit `json:"hits"`
}

type AccessPolicySearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  AccessPolicyHits `json:"hits"`
}

type AccessPolicyPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccessPolicyPaginator(filters []essdk.BoolFilter, limit *int64) (AccessPolicyPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_access_policy", filters, limit)
	if err != nil {
		return AccessPolicyPaginator{}, err
	}

	p := AccessPolicyPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccessPolicyPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccessPolicyPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccessPolicyPaginator) NextPage(ctx context.Context) ([]AccessPolicy, error) {
	var response AccessPolicySearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccessPolicy
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccessPolicyFilters = map[string]string{
	"account_id":                     "Description.AccountID",
	"application_id":                 "Description.ApplicationID",
	"application_name":               "Description.ApplicationName",
	"approval_groups":                "Description.ApprovalGroups",
	"created_at":                     "Description.CreatedAt",
	"decision":                       "Description.Decision",
	"exclude":                        "Description.Exclude",
	"id":                             "Description.ID",
	"include":                        "Description.Include",
	"name":                           "Description.Name",
	"precedence":                     "Description.Precedence",
	"purpose_justification_prompt":   "Description.PurposeJustificationPrompt",
	"purpose_justification_required": "Description.PurposeJustificationRequired",
	"require":                        "Description.Require",
	"updated_at":                     "Description.UpdatedAt",
}

func ListAccessPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccessPolicy")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccessPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccessPolicyFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccessPolicy NewAccessPolicyPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccessPolicy paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccessPolicyFilters = map[string]string{
	"account_id":                     "Description.AccountID",
	"application_id":                 "Description.ApplicationID",
	"application_name":               "Description.ApplicationName",
	"approval_groups":                "Description.ApprovalGroups",
	"created_at":                     "Description.CreatedAt",
	"decision":                       "Description.Decision",
	"exclude":                        "Description.Exclude",
	"id":                             "Description.ID",
	"include":                        "Description.Include",
	"name":                           "Description.Name",
	"precedence":                     "Description.Precedence",
	"purpose_justification_prompt":   "Description.PurposeJustificationPrompt",
	"purpose_justification_required": "Description.PurposeJustificationRequired",
	"require":                        "Description.Require",
	"updated_at":                     "Description.UpdatedAt",
}

func GetAccessPolicy(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccessPolicy")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccessPolicyPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccessPolicyFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccessPolicy =============================

// ==========================  START: Account =============================

type Account struct {
	ResourceID      string                        `json:"resource_id"`
	PlatformID      string                        `json:"platform_id"`
	Description     cloudflare.AccountDescription `json:"Description"`
	Metadata        cloudflare.Metadata           `json:"metadata"`
	DescribedBy     string                        `json:"described_by"`
	ResourceType    string                        `json:"resource_type"`
	IntegrationType string                        `json:"integration_type"`
	IntegrationID   string                        `json:"integration_id"`
}

type AccountHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Account       `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccountHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AccountHit      `json:"hits"`
}

type AccountSearchResponse struct {
	PitID string      `json:"pit_id"`
	Hits  AccountHits `json:"hits"`
}

type AccountPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountPaginator(filters []essdk.BoolFilter, limit *int64) (AccountPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_account", filters, limit)
	if err != nil {
		return AccountPaginator{}, err
	}

	p := AccountPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccountPaginator) NextPage(ctx context.Context) ([]Account, error) {
	var response AccountSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Account
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountFilters = map[string]string{
	"id":       "Description.ID",
	"name":     "Description.Name",
	"settings": "Description.Settings",
	"type":     "Description.Type",
}

func ListAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccount")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccount NewAccountPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccount paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccountFilters = map[string]string{
	"id":       "Description.ID",
	"name":     "Description.Name",
	"settings": "Description.Settings",
	"type":     "Description.Type",
}

func GetAccount(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccount")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccountPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccountFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Account =============================

// ==========================  START: AccountMember =============================

type AccountMember struct {
	ResourceID      string                              `json:"resource_id"`
	PlatformID      string                              `json:"platform_id"`
	Description     cloudflare.AccountMemberDescription `json:"Description"`
	Metadata        cloudflare.Metadata                 `json:"metadata"`
	DescribedBy     string                              `json:"described_by"`
	ResourceType    string                              `json:"resource_type"`
	IntegrationType string                              `json:"integration_type"`
	IntegrationID   string                              `json:"integration_id"`
}

type AccountMemberHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AccountMember `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccountMemberHits struct {
	Total essdk.SearchTotal  `json:"total"`
	Hits  []AccountMemberHit `json:"hits"`
}

type AccountMemberSearchResponse struct {
	PitID string            `json:"pit_id"`
	Hits  AccountMemberHits `json:"hits"`
}

type AccountMemberPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountMemberPaginator(filters []essdk.BoolFilter, limit *int64) (AccountMemberPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_account_member", filters, limit)
	if err != nil {
		return AccountMemberPaginator{}, err
	}

	p := AccountMemberPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountMemberPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountMemberPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccountMemberPaginator) NextPage(ctx context.Context) ([]AccountMember, error) {
	var response AccountMemberSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccountMember
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountMemberFilters = map[string]string{
	"account_id": "Description.AccountID",
	"code":       "Description.Code",
	"id":         "Description.ID",
	"roles":      "Description.Roles",
	"status":     "Description.Status",
	"title":      "Description.Title",
	"user":       "Description.User",
	"user_email": "Description.UserEmail",
}

func ListAccountMember(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccountMember")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountMember NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountMember NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountMember GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountMember GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountMember GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccountMemberPaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccountMemberFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountMember NewAccountMemberPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccountMember paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccountMemberFilters = map[string]string{
	"account_id": "Description.AccountID",
	"code":       "Description.Code",
	"id":         "Description.ID",
	"roles":      "Description.Roles",
	"status":     "Description.Status",
	"title":      "Description.Title",
	"user":       "Description.User",
	"user_email": "Description.UserEmail",
}

func GetAccountMember(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccountMember")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccountMemberPaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccountMemberFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccountMember =============================

// ==========================  START: AccountRole =============================

type AccountRole struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     cloudflare.AccountRoleDescription `json:"Description"`
	Metadata        cloudflare.Metadata               `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type AccountRoleHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  AccountRole   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type AccountRoleHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []AccountRoleHit  `json:"hits"`
}

type AccountRoleSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  AccountRoleHits `json:"hits"`
}

type AccountRolePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewAccountRolePaginator(filters []essdk.BoolFilter, limit *int64) (AccountRolePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_account_role", filters, limit)
	if err != nil {
		return AccountRolePaginator{}, err
	}

	p := AccountRolePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p AccountRolePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p AccountRolePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p AccountRolePaginator) NextPage(ctx context.Context) ([]AccountRole, error) {
	var response AccountRoleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []AccountRole
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listAccountRoleFilters = map[string]string{
	"account_id":  "Description.AccountID",
	"description": "Description.Description",
	"id":          "Description.ID",
	"name":        "Description.Name",
	"permissions": "Description.Permissions",
	"title":       "Description.Title",
}

func ListAccountRole(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListAccountRole")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountRole NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountRole NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountRole GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountRole GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountRole GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewAccountRolePaginator(essdk.BuildFilter(ctx, d.QueryContext, listAccountRoleFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListAccountRole NewAccountRolePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListAccountRole paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getAccountRoleFilters = map[string]string{
	"account_id":  "Description.AccountID",
	"description": "Description.Description",
	"id":          "Description.ID",
	"name":        "Description.Name",
	"permissions": "Description.Permissions",
	"title":       "Description.Title",
}

func GetAccountRole(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetAccountRole")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewAccountRolePaginator(essdk.BuildFilter(ctx, d.QueryContext, getAccountRoleFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: AccountRole =============================

// ==========================  START: ApiToken =============================

type ApiToken struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     cloudflare.ApiTokenDescription `json:"Description"`
	Metadata        cloudflare.Metadata            `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type ApiTokenHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  ApiToken      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ApiTokenHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ApiTokenHit     `json:"hits"`
}

type ApiTokenSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  ApiTokenHits `json:"hits"`
}

type ApiTokenPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewApiTokenPaginator(filters []essdk.BoolFilter, limit *int64) (ApiTokenPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_apitoken", filters, limit)
	if err != nil {
		return ApiTokenPaginator{}, err
	}

	p := ApiTokenPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ApiTokenPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ApiTokenPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ApiTokenPaginator) NextPage(ctx context.Context) ([]ApiToken, error) {
	var response ApiTokenSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []ApiToken
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listApiTokenFilters = map[string]string{
	"condition":   "Description.Condition",
	"expires_on":  "Description.ExpiresOn",
	"id":          "Description.ID",
	"issued_on":   "Description.IssuedOn",
	"modified_on": "Description.ModifiedOn",
	"name":        "Description.Name",
	"not_before":  "Description.NotBefore",
	"policies":    "Description.Policies",
	"status":      "Description.Status",
}

func ListApiToken(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListApiToken")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiToken NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiToken NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiToken GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiToken GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiToken GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewApiTokenPaginator(essdk.BuildFilter(ctx, d.QueryContext, listApiTokenFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListApiToken NewApiTokenPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListApiToken paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getApiTokenFilters = map[string]string{
	"condition":   "Description.Condition",
	"expires_on":  "Description.ExpiresOn",
	"id":          "Description.ID",
	"issued_on":   "Description.IssuedOn",
	"modified_on": "Description.ModifiedOn",
	"name":        "Description.Name",
	"not_before":  "Description.NotBefore",
	"policies":    "Description.Policies",
	"status":      "Description.Status",
}

func GetApiToken(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetApiToken")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewApiTokenPaginator(essdk.BuildFilter(ctx, d.QueryContext, getApiTokenFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: ApiToken =============================

// ==========================  START: DNSRecord =============================

type DNSRecord struct {
	ResourceID      string                          `json:"resource_id"`
	PlatformID      string                          `json:"platform_id"`
	Description     cloudflare.DNSRecordDescription `json:"Description"`
	Metadata        cloudflare.Metadata             `json:"metadata"`
	DescribedBy     string                          `json:"described_by"`
	ResourceType    string                          `json:"resource_type"`
	IntegrationType string                          `json:"integration_type"`
	IntegrationID   string                          `json:"integration_id"`
}

type DNSRecordHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  DNSRecord     `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type DNSRecordHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []DNSRecordHit    `json:"hits"`
}

type DNSRecordSearchResponse struct {
	PitID string        `json:"pit_id"`
	Hits  DNSRecordHits `json:"hits"`
}

type DNSRecordPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewDNSRecordPaginator(filters []essdk.BoolFilter, limit *int64) (DNSRecordPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_dnsrecord", filters, limit)
	if err != nil {
		return DNSRecordPaginator{}, err
	}

	p := DNSRecordPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p DNSRecordPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p DNSRecordPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p DNSRecordPaginator) NextPage(ctx context.Context) ([]DNSRecord, error) {
	var response DNSRecordSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []DNSRecord
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listDNSRecordFilters = map[string]string{
	"content":     "Description.Content",
	"created_on":  "Description.CreatedOn",
	"data":        "Description.Data",
	"id":          "Description.ID",
	"locked":      "Description.Locked",
	"meta":        "Description.Meta",
	"modified_on": "Description.ModifiedOn",
	"name":        "Description.Name",
	"priority":    "Description.Priority",
	"proxiable":   "Description.Proxiable",
	"proxied":     "Description.Proxied",
	"ttl":         "Description.TTL",
	"type":        "Description.Type",
	"zone_id":     "Description.ZoneID",
	"zone_name":   "Description.ZoneName",
}

func ListDNSRecord(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListDNSRecord")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewDNSRecordPaginator(essdk.BuildFilter(ctx, d.QueryContext, listDNSRecordFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListDNSRecord NewDNSRecordPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListDNSRecord paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getDNSRecordFilters = map[string]string{
	"content":     "Description.Content",
	"created_on":  "Description.CreatedOn",
	"data":        "Description.Data",
	"id":          "Description.ID",
	"locked":      "Description.Locked",
	"meta":        "Description.Meta",
	"modified_on": "Description.ModifiedOn",
	"name":        "Description.Name",
	"priority":    "Description.Priority",
	"proxiable":   "Description.Proxiable",
	"proxied":     "Description.Proxied",
	"ttl":         "Description.TTL",
	"type":        "Description.Type",
	"zone_id":     "Description.ZoneID",
	"zone_name":   "Description.ZoneName",
}

func GetDNSRecord(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetDNSRecord")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewDNSRecordPaginator(essdk.BuildFilter(ctx, d.QueryContext, getDNSRecordFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: DNSRecord =============================

// ==========================  START: FireWallRule =============================

type FireWallRule struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     cloudflare.FireWallRuleDescription `json:"Description"`
	Metadata        cloudflare.Metadata                `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type FireWallRuleHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  FireWallRule  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type FireWallRuleHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []FireWallRuleHit `json:"hits"`
}

type FireWallRuleSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  FireWallRuleHits `json:"hits"`
}

type FireWallRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewFireWallRulePaginator(filters []essdk.BoolFilter, limit *int64) (FireWallRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_firewall_rule", filters, limit)
	if err != nil {
		return FireWallRulePaginator{}, err
	}

	p := FireWallRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p FireWallRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p FireWallRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p FireWallRulePaginator) NextPage(ctx context.Context) ([]FireWallRule, error) {
	var response FireWallRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []FireWallRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listFireWallRuleFilters = map[string]string{
	"action":      "Description.Action",
	"created_on":  "Description.CreatedOn",
	"description": "Description.Description",
	"filter":      "Description.Filter",
	"id":          "Description.ID",
	"modified_on": "Description.ModifiedOn",
	"paused":      "Description.Paused",
	"priority":    "Description.Priority",
	"products":    "Description.Products",
	"title":       "Description.Title",
	"zone_id":     "Description.ZoneID",
}

func ListFireWallRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListFireWallRule")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewFireWallRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listFireWallRuleFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListFireWallRule NewFireWallRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListFireWallRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getFireWallRuleFilters = map[string]string{
	"action":      "Description.Action",
	"created_on":  "Description.CreatedOn",
	"description": "Description.Description",
	"filter":      "Description.Filter",
	"id":          "Description.ID",
	"modified_on": "Description.ModifiedOn",
	"paused":      "Description.Paused",
	"priority":    "Description.Priority",
	"products":    "Description.Products",
	"title":       "Description.Title",
	"zone_id":     "Description.ZoneID",
}

func GetFireWallRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetFireWallRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewFireWallRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getFireWallRuleFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: FireWallRule =============================

// ==========================  START: LoadBalancer =============================

type LoadBalancer struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     cloudflare.LoadBalancerDescription `json:"Description"`
	Metadata        cloudflare.Metadata                `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type LoadBalancerHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  LoadBalancer  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type LoadBalancerHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []LoadBalancerHit `json:"hits"`
}

type LoadBalancerSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  LoadBalancerHits `json:"hits"`
}

type LoadBalancerPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerPaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_loadbalancer", filters, limit)
	if err != nil {
		return LoadBalancerPaginator{}, err
	}

	p := LoadBalancerPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LoadBalancerPaginator) NextPage(ctx context.Context) ([]LoadBalancer, error) {
	var response LoadBalancerSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancer
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerFilters = map[string]string{
	"created_on":                  "Description.CreatedOn",
	"default_pools":               "Description.DefaultPools",
	"description":                 "Description.Description",
	"enabled":                     "Description.Enabled",
	"fallback_pool":               "Description.FallbackPool",
	"id":                          "Description.ID",
	"modified_on":                 "Description.ModifiedOn",
	"name":                        "Description.Name",
	"pop_pools":                   "Description.PopPools",
	"proxied":                     "Description.Proxied",
	"region_pools":                "Description.RegionPools",
	"session_affinity":            "Description.SessionAffinity",
	"session_affinity_attributes": "Description.SessionAffinityAttributes",
	"session_affinity_ttl":        "Description.SessionAffinityTTL",
	"steering_policy":             "Description.SteeringPolicy",
	"ttl":                         "Description.TTL",
	"zone_id":                     "Description.ZoneID",
	"zone_name":                   "Description.ZoneName",
}

func ListLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancer")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLoadBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLoadBalancerFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancer NewLoadBalancerPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLoadBalancer paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLoadBalancerFilters = map[string]string{
	"created_on":                  "Description.CreatedOn",
	"default_pools":               "Description.DefaultPools",
	"description":                 "Description.Description",
	"enabled":                     "Description.Enabled",
	"fallback_pool":               "Description.FallbackPool",
	"id":                          "Description.ID",
	"modified_on":                 "Description.ModifiedOn",
	"name":                        "Description.Name",
	"pop_pools":                   "Description.PopPools",
	"proxied":                     "Description.Proxied",
	"region_pools":                "Description.RegionPools",
	"session_affinity":            "Description.SessionAffinity",
	"session_affinity_attributes": "Description.SessionAffinityAttributes",
	"session_affinity_ttl":        "Description.SessionAffinityTTL",
	"steering_policy":             "Description.SteeringPolicy",
	"ttl":                         "Description.TTL",
	"zone_id":                     "Description.ZoneID",
	"zone_name":                   "Description.ZoneName",
}

func GetLoadBalancer(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancer")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLoadBalancerFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LoadBalancer =============================

// ==========================  START: LoadBalancerMonitor =============================

type LoadBalancerMonitor struct {
	ResourceID      string                                    `json:"resource_id"`
	PlatformID      string                                    `json:"platform_id"`
	Description     cloudflare.LoadBalancerMonitorDescription `json:"Description"`
	Metadata        cloudflare.Metadata                       `json:"metadata"`
	DescribedBy     string                                    `json:"described_by"`
	ResourceType    string                                    `json:"resource_type"`
	IntegrationType string                                    `json:"integration_type"`
	IntegrationID   string                                    `json:"integration_id"`
}

type LoadBalancerMonitorHit struct {
	ID      string              `json:"_id"`
	Score   float64             `json:"_score"`
	Index   string              `json:"_index"`
	Type    string              `json:"_type"`
	Version int64               `json:"_version,omitempty"`
	Source  LoadBalancerMonitor `json:"_source"`
	Sort    []interface{}       `json:"sort"`
}

type LoadBalancerMonitorHits struct {
	Total essdk.SearchTotal        `json:"total"`
	Hits  []LoadBalancerMonitorHit `json:"hits"`
}

type LoadBalancerMonitorSearchResponse struct {
	PitID string                  `json:"pit_id"`
	Hits  LoadBalancerMonitorHits `json:"hits"`
}

type LoadBalancerMonitorPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerMonitorPaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerMonitorPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_loadbalancer_monitor", filters, limit)
	if err != nil {
		return LoadBalancerMonitorPaginator{}, err
	}

	p := LoadBalancerMonitorPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerMonitorPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerMonitorPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LoadBalancerMonitorPaginator) NextPage(ctx context.Context) ([]LoadBalancerMonitor, error) {
	var response LoadBalancerMonitorSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerMonitor
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerMonitorFilters = map[string]string{
	"allow_insecure":   "Description.AllowInsecure",
	"created_on":       "Description.CreatedOn",
	"description":      "Description.Description",
	"expected_body":    "Description.ExpectedBody",
	"expected_codes":   "Description.ExpectedCodes",
	"follow_redirects": "Description.FollowRedirects",
	"header":           "Description.Header",
	"id":               "Description.ID",
	"interval":         "Description.Interval",
	"method":           "Description.Method",
	"modified_on":      "Description.ModifiedOn",
	"path":             "Description.Path",
	"port":             "Description.Port",
	"probe_zone":       "Description.ProbeZone",
	"retries":          "Description.Retries",
	"timeout":          "Description.Timeout",
	"type":             "Description.Type",
}

func ListLoadBalancerMonitor(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerMonitor")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerMonitor NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerMonitor NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerMonitor GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerMonitor GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerMonitor GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLoadBalancerMonitorPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLoadBalancerMonitorFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerMonitor NewLoadBalancerMonitorPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLoadBalancerMonitor paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLoadBalancerMonitorFilters = map[string]string{
	"allow_insecure":   "Description.AllowInsecure",
	"created_on":       "Description.CreatedOn",
	"description":      "Description.Description",
	"expected_body":    "Description.ExpectedBody",
	"expected_codes":   "Description.ExpectedCodes",
	"follow_redirects": "Description.FollowRedirects",
	"header":           "Description.Header",
	"id":               "Description.ID",
	"interval":         "Description.Interval",
	"method":           "Description.Method",
	"modified_on":      "Description.ModifiedOn",
	"path":             "Description.Path",
	"port":             "Description.Port",
	"probe_zone":       "Description.ProbeZone",
	"retries":          "Description.Retries",
	"timeout":          "Description.Timeout",
	"type":             "Description.Type",
}

func GetLoadBalancerMonitor(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerMonitor")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerMonitorPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLoadBalancerMonitorFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LoadBalancerMonitor =============================

// ==========================  START: LoadBalancerPool =============================

type LoadBalancerPool struct {
	ResourceID      string                                 `json:"resource_id"`
	PlatformID      string                                 `json:"platform_id"`
	Description     cloudflare.LoadBalancerPoolDescription `json:"Description"`
	Metadata        cloudflare.Metadata                    `json:"metadata"`
	DescribedBy     string                                 `json:"described_by"`
	ResourceType    string                                 `json:"resource_type"`
	IntegrationType string                                 `json:"integration_type"`
	IntegrationID   string                                 `json:"integration_id"`
}

type LoadBalancerPoolHit struct {
	ID      string           `json:"_id"`
	Score   float64          `json:"_score"`
	Index   string           `json:"_index"`
	Type    string           `json:"_type"`
	Version int64            `json:"_version,omitempty"`
	Source  LoadBalancerPool `json:"_source"`
	Sort    []interface{}    `json:"sort"`
}

type LoadBalancerPoolHits struct {
	Total essdk.SearchTotal     `json:"total"`
	Hits  []LoadBalancerPoolHit `json:"hits"`
}

type LoadBalancerPoolSearchResponse struct {
	PitID string               `json:"pit_id"`
	Hits  LoadBalancerPoolHits `json:"hits"`
}

type LoadBalancerPoolPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewLoadBalancerPoolPaginator(filters []essdk.BoolFilter, limit *int64) (LoadBalancerPoolPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_loadbalancer_pool", filters, limit)
	if err != nil {
		return LoadBalancerPoolPaginator{}, err
	}

	p := LoadBalancerPoolPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p LoadBalancerPoolPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p LoadBalancerPoolPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p LoadBalancerPoolPaginator) NextPage(ctx context.Context) ([]LoadBalancerPool, error) {
	var response LoadBalancerPoolSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []LoadBalancerPool
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listLoadBalancerPoolFilters = map[string]string{
	"check_regions":      "Description.CheckRegions",
	"created_on":         "Description.CreatedOn",
	"description":        "Description.Description",
	"enabled":            "Description.Enabled",
	"id":                 "Description.ID",
	"latitude":           "Description.Latitude",
	"load_shedding":      "Description.LoadShedding",
	"longitude":          "Description.Longitude",
	"minimum_origins":    "Description.MinimumOrigins",
	"modified_on":        "Description.ModifiedOn",
	"monitor":            "Description.Monitor",
	"name":               "Description.Name",
	"notification_email": "Description.NotificationEmail",
	"origins":            "Description.Origins",
}

func ListLoadBalancerPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListLoadBalancerPool")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerPool NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerPool NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerPool GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewLoadBalancerPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, listLoadBalancerPoolFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListLoadBalancerPool NewLoadBalancerPoolPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListLoadBalancerPool paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getLoadBalancerPoolFilters = map[string]string{
	"check_regions":      "Description.CheckRegions",
	"created_on":         "Description.CreatedOn",
	"description":        "Description.Description",
	"enabled":            "Description.Enabled",
	"id":                 "Description.ID",
	"latitude":           "Description.Latitude",
	"load_shedding":      "Description.LoadShedding",
	"longitude":          "Description.Longitude",
	"minimum_origins":    "Description.MinimumOrigins",
	"modified_on":        "Description.ModifiedOn",
	"monitor":            "Description.Monitor",
	"name":               "Description.Name",
	"notification_email": "Description.NotificationEmail",
	"origins":            "Description.Origins",
}

func GetLoadBalancerPool(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetLoadBalancerPool")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewLoadBalancerPoolPaginator(essdk.BuildFilter(ctx, d.QueryContext, getLoadBalancerPoolFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: LoadBalancerPool =============================

// ==========================  START: PageRule =============================

type PageRule struct {
	ResourceID      string                         `json:"resource_id"`
	PlatformID      string                         `json:"platform_id"`
	Description     cloudflare.PageRuleDescription `json:"Description"`
	Metadata        cloudflare.Metadata            `json:"metadata"`
	DescribedBy     string                         `json:"described_by"`
	ResourceType    string                         `json:"resource_type"`
	IntegrationType string                         `json:"integration_type"`
	IntegrationID   string                         `json:"integration_id"`
}

type PageRuleHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  PageRule      `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type PageRuleHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []PageRuleHit     `json:"hits"`
}

type PageRuleSearchResponse struct {
	PitID string       `json:"pit_id"`
	Hits  PageRuleHits `json:"hits"`
}

type PageRulePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewPageRulePaginator(filters []essdk.BoolFilter, limit *int64) (PageRulePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_pagerule", filters, limit)
	if err != nil {
		return PageRulePaginator{}, err
	}

	p := PageRulePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p PageRulePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p PageRulePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p PageRulePaginator) NextPage(ctx context.Context) ([]PageRule, error) {
	var response PageRuleSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []PageRule
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listPageRuleFilters = map[string]string{
	"actions":     "Description.Actions",
	"created_on":  "Description.CreatedOn",
	"id":          "Description.ID",
	"modified_on": "Description.ModifiedOn",
	"priority":    "Description.Priority",
	"status":      "Description.Status",
	"targets":     "Description.Targets",
	"title":       "Description.Title",
	"zone_id":     "Description.ZoneID",
}

func ListPageRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListPageRule")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListPageRule NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListPageRule NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListPageRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListPageRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListPageRule GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewPageRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, listPageRuleFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListPageRule NewPageRulePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListPageRule paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getPageRuleFilters = map[string]string{
	"actions":     "Description.Actions",
	"created_on":  "Description.CreatedOn",
	"id":          "Description.ID",
	"modified_on": "Description.ModifiedOn",
	"priority":    "Description.Priority",
	"status":      "Description.Status",
	"targets":     "Description.Targets",
	"title":       "Description.Title",
	"zone_id":     "Description.ZoneID",
}

func GetPageRule(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetPageRule")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewPageRulePaginator(essdk.BuildFilter(ctx, d.QueryContext, getPageRuleFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: PageRule =============================

// ==========================  START: User =============================

type User struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     cloudflare.UserDescription `json:"Description"`
	Metadata        cloudflare.Metadata        `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type UserHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  User          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type UserHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []UserHit         `json:"hits"`
}

type UserSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  UserHits `json:"hits"`
}

type UserPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewUserPaginator(filters []essdk.BoolFilter, limit *int64) (UserPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_user", filters, limit)
	if err != nil {
		return UserPaginator{}, err
	}

	p := UserPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p UserPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p UserPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p UserPaginator) NextPage(ctx context.Context) ([]User, error) {
	var response UserSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []User
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listUserFilters = map[string]string{
	"api_key":                           "Description.APIKey",
	"betas":                             "Description.Betas",
	"country":                           "Description.Country",
	"created_on":                        "Description.CreatedOn",
	"email":                             "Description.Email",
	"first_name":                        "Description.FirstName",
	"id":                                "Description.ID",
	"last_name":                         "Description.LastName",
	"modified_on":                       "Description.ModifiedOn",
	"organizations":                     "Description.Organizations",
	"telephone":                         "Description.Telephone",
	"two_factor_authentication_enabled": "Description.TwoFactorAuthenticationEnabled",
	"username":                          "Description.Username",
	"zipcode":                           "Description.Zipcode",
}

func ListUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListUser")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, listUserFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListUser NewUserPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListUser paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getUserFilters = map[string]string{
	"api_key":                           "Description.APIKey",
	"betas":                             "Description.Betas",
	"country":                           "Description.Country",
	"created_on":                        "Description.CreatedOn",
	"email":                             "Description.Email",
	"first_name":                        "Description.FirstName",
	"id":                                "Description.ID",
	"last_name":                         "Description.LastName",
	"modified_on":                       "Description.ModifiedOn",
	"organizations":                     "Description.Organizations",
	"telephone":                         "Description.Telephone",
	"two_factor_authentication_enabled": "Description.TwoFactorAuthenticationEnabled",
	"username":                          "Description.Username",
	"zipcode":                           "Description.Zipcode",
}

func GetUser(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetUser")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewUserPaginator(essdk.BuildFilter(ctx, d.QueryContext, getUserFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: User =============================

// ==========================  START: UserAuditLog =============================

type UserAuditLog struct {
	ResourceID      string                             `json:"resource_id"`
	PlatformID      string                             `json:"platform_id"`
	Description     cloudflare.UserAuditLogDescription `json:"Description"`
	Metadata        cloudflare.Metadata                `json:"metadata"`
	DescribedBy     string                             `json:"described_by"`
	ResourceType    string                             `json:"resource_type"`
	IntegrationType string                             `json:"integration_type"`
	IntegrationID   string                             `json:"integration_id"`
}

type UserAuditLogHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  UserAuditLog  `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type UserAuditLogHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []UserAuditLogHit `json:"hits"`
}

type UserAuditLogSearchResponse struct {
	PitID string           `json:"pit_id"`
	Hits  UserAuditLogHits `json:"hits"`
}

type UserAuditLogPaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewUserAuditLogPaginator(filters []essdk.BoolFilter, limit *int64) (UserAuditLogPaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_user_auditlog", filters, limit)
	if err != nil {
		return UserAuditLogPaginator{}, err
	}

	p := UserAuditLogPaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p UserAuditLogPaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p UserAuditLogPaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p UserAuditLogPaginator) NextPage(ctx context.Context) ([]UserAuditLog, error) {
	var response UserAuditLogSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []UserAuditLog
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listUserAuditLogFilters = map[string]string{
	"action":         "Description.Action",
	"actor_email":    "Description.ActorEmail",
	"actor_id":       "Description.ActorID",
	"actor_ip":       "Description.ActorIP",
	"actor_type":     "Description.ActorType",
	"id":             "Description.ID",
	"metadata":       "Description.Metadata",
	"new_value":      "Description.NewValue",
	"new_value_json": "Description.NewValueJSON",
	"old_value":      "Description.OldValue",
	"old_value_json": "Description.OldValueJSON",
	"owner_id":       "Description.OwnerID",
	"resource":       "Description.Resource",
}

func ListUserAuditLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListUserAuditLog")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserAuditLog NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserAuditLog NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserAuditLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserAuditLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserAuditLog GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewUserAuditLogPaginator(essdk.BuildFilter(ctx, d.QueryContext, listUserAuditLogFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListUserAuditLog NewUserAuditLogPaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListUserAuditLog paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getUserAuditLogFilters = map[string]string{
	"action":         "Description.Action",
	"actor_email":    "Description.ActorEmail",
	"actor_id":       "Description.ActorID",
	"actor_ip":       "Description.ActorIP",
	"actor_type":     "Description.ActorType",
	"id":             "Description.ID",
	"metadata":       "Description.Metadata",
	"new_value":      "Description.NewValue",
	"new_value_json": "Description.NewValueJSON",
	"old_value":      "Description.OldValue",
	"old_value_json": "Description.OldValueJSON",
	"owner_id":       "Description.OwnerID",
	"resource":       "Description.Resource",
}

func GetUserAuditLog(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetUserAuditLog")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewUserAuditLogPaginator(essdk.BuildFilter(ctx, d.QueryContext, getUserAuditLogFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: UserAuditLog =============================

// ==========================  START: WorkerRoute =============================

type WorkerRoute struct {
	ResourceID      string                            `json:"resource_id"`
	PlatformID      string                            `json:"platform_id"`
	Description     cloudflare.WorkerRouteDescription `json:"Description"`
	Metadata        cloudflare.Metadata               `json:"metadata"`
	DescribedBy     string                            `json:"described_by"`
	ResourceType    string                            `json:"resource_type"`
	IntegrationType string                            `json:"integration_type"`
	IntegrationID   string                            `json:"integration_id"`
}

type WorkerRouteHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  WorkerRoute   `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type WorkerRouteHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []WorkerRouteHit  `json:"hits"`
}

type WorkerRouteSearchResponse struct {
	PitID string          `json:"pit_id"`
	Hits  WorkerRouteHits `json:"hits"`
}

type WorkerRoutePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewWorkerRoutePaginator(filters []essdk.BoolFilter, limit *int64) (WorkerRoutePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_workerroute", filters, limit)
	if err != nil {
		return WorkerRoutePaginator{}, err
	}

	p := WorkerRoutePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p WorkerRoutePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p WorkerRoutePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p WorkerRoutePaginator) NextPage(ctx context.Context) ([]WorkerRoute, error) {
	var response WorkerRouteSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []WorkerRoute
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listWorkerRouteFilters = map[string]string{
	"id":        "Description.ID",
	"pattern":   "Description.Pattern",
	"script":    "Description.Script",
	"zone_id":   "Description.ZoneID",
	"zone_name": "Description.ZoneName",
}

func ListWorkerRoute(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListWorkerRoute")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkerRoute NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkerRoute NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkerRoute GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkerRoute GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkerRoute GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewWorkerRoutePaginator(essdk.BuildFilter(ctx, d.QueryContext, listWorkerRouteFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListWorkerRoute NewWorkerRoutePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListWorkerRoute paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getWorkerRouteFilters = map[string]string{
	"id":        "Description.ID",
	"pattern":   "Description.Pattern",
	"script":    "Description.Script",
	"zone_id":   "Description.ZoneID",
	"zone_name": "Description.ZoneName",
}

func GetWorkerRoute(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetWorkerRoute")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewWorkerRoutePaginator(essdk.BuildFilter(ctx, d.QueryContext, getWorkerRouteFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: WorkerRoute =============================

// ==========================  START: Zone =============================

type Zone struct {
	ResourceID      string                     `json:"resource_id"`
	PlatformID      string                     `json:"platform_id"`
	Description     cloudflare.ZoneDescription `json:"Description"`
	Metadata        cloudflare.Metadata        `json:"metadata"`
	DescribedBy     string                     `json:"described_by"`
	ResourceType    string                     `json:"resource_type"`
	IntegrationType string                     `json:"integration_type"`
	IntegrationID   string                     `json:"integration_id"`
}

type ZoneHit struct {
	ID      string        `json:"_id"`
	Score   float64       `json:"_score"`
	Index   string        `json:"_index"`
	Type    string        `json:"_type"`
	Version int64         `json:"_version,omitempty"`
	Source  Zone          `json:"_source"`
	Sort    []interface{} `json:"sort"`
}

type ZoneHits struct {
	Total essdk.SearchTotal `json:"total"`
	Hits  []ZoneHit         `json:"hits"`
}

type ZoneSearchResponse struct {
	PitID string   `json:"pit_id"`
	Hits  ZoneHits `json:"hits"`
}

type ZonePaginator struct {
	paginator *essdk.BaseESPaginator
}

func (k Client) NewZonePaginator(filters []essdk.BoolFilter, limit *int64) (ZonePaginator, error) {
	paginator, err := essdk.NewPaginator(k.ES(), "cloudflare_zone", filters, limit)
	if err != nil {
		return ZonePaginator{}, err
	}

	p := ZonePaginator{
		paginator: paginator,
	}

	return p, nil
}

func (p ZonePaginator) HasNext() bool {
	return !p.paginator.Done()
}

func (p ZonePaginator) Close(ctx context.Context) error {
	return p.paginator.Deallocate(ctx)
}

func (p ZonePaginator) NextPage(ctx context.Context) ([]Zone, error) {
	var response ZoneSearchResponse
	err := p.paginator.Search(ctx, &response)
	if err != nil {
		return nil, err
	}

	var values []Zone
	for _, hit := range response.Hits.Hits {
		values = append(values, hit.Source)
	}

	hits := int64(len(response.Hits.Hits))
	if hits > 0 {
		p.paginator.UpdateState(hits, response.Hits.Hits[hits-1].Sort, response.PitID)
	} else {
		p.paginator.UpdateState(hits, nil, "")
	}

	return values, nil
}

var listZoneFilters = map[string]string{
	"betas":                 "Description.Betas",
	"created_on":            "Description.CreatedOn",
	"deactivation_reason":   "Description.DeactivationReason",
	"development_mode":      "Description.DevelopmentMode",
	"dnssec":                "Description.DNSSEC",
	"host":                  "Description.Host",
	"id":                    "Description.ID",
	"meta":                  "Description.Meta",
	"modified_on":           "Description.ModifiedOn",
	"name":                  "Description.Name",
	"name_servers":          "Description.NameServers",
	"original_dnshost":      "Description.OriginalDNSHost",
	"original_name_servers": "Description.OriginalNameServers",
	"original_registrar":    "Description.OriginalRegistrar",
	"owner":                 "Description.Owner",
	"paused":                "Description.Paused",
	"permissions":           "Description.Permissions",
	"plan":                  "Description.Plan",
	"plan_pending":          "Description.PlanPending",
	"status":                "Description.Status",
	"type":                  "Description.Type",
	"vanity_name_servers":   "Description.VanityNameServers",
}

func ListZone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("ListZone")
	runtime.GC()

	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		plugin.Logger(ctx).Error("ListZone NewClientCached", "error", err)
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		plugin.Logger(ctx).Error("ListZone NewSelfClientCached", "error", err)
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		plugin.Logger(ctx).Error("ListZone GetConfigTableValueOrNil for OpenGovernanceConfigKeyIntegrationID", "error", err)
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		plugin.Logger(ctx).Error("ListZone GetConfigTableValueOrNil for OpenGovernanceConfigKeyResourceCollectionFilters", "error", err)
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		plugin.Logger(ctx).Error("ListZone GetConfigTableValueOrNil for OpenGovernanceConfigKeyClientType", "error", err)
		return nil, err
	}

	paginator, err := k.NewZonePaginator(essdk.BuildFilter(ctx, d.QueryContext, listZoneFilters, integrationId, encodedResourceCollectionFilters, clientType), d.QueryContext.Limit)
	if err != nil {
		plugin.Logger(ctx).Error("ListZone NewZonePaginator", "error", err)
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			plugin.Logger(ctx).Error("ListZone paginator.NextPage", "error", err)
			return nil, err
		}

		for _, v := range page {
			d.StreamListItem(ctx, v)
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

var getZoneFilters = map[string]string{
	"betas":                 "Description.Betas",
	"created_on":            "Description.CreatedOn",
	"deactivation_reason":   "Description.DeactivationReason",
	"development_mode":      "Description.DevelopmentMode",
	"dnssec":                "Description.DNSSEC",
	"host":                  "Description.Host",
	"id":                    "Description.ID",
	"meta":                  "Description.Meta",
	"modified_on":           "Description.ModifiedOn",
	"name":                  "Description.Name",
	"name_servers":          "Description.NameServers",
	"original_dnshost":      "Description.OriginalDNSHost",
	"original_name_servers": "Description.OriginalNameServers",
	"original_registrar":    "Description.OriginalRegistrar",
	"owner":                 "Description.Owner",
	"paused":                "Description.Paused",
	"permissions":           "Description.Permissions",
	"plan":                  "Description.Plan",
	"plan_pending":          "Description.PlanPending",
	"status":                "Description.Status",
	"type":                  "Description.Type",
	"vanity_name_servers":   "Description.VanityNameServers",
}

func GetZone(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("GetZone")
	runtime.GC()
	// create service
	cfg := essdk.GetConfig(d.Connection)
	ke, err := essdk.NewClientCached(cfg, d.ConnectionCache, ctx)
	if err != nil {
		return nil, err
	}
	k := Client{Client: ke}

	sc, err := steampipesdk.NewSelfClientCached(ctx, d.ConnectionCache)
	if err != nil {
		return nil, err
	}
	integrationId, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyIntegrationID)
	if err != nil {
		return nil, err
	}
	encodedResourceCollectionFilters, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyResourceCollectionFilters)
	if err != nil {
		return nil, err
	}
	clientType, err := sc.GetConfigTableValueOrNil(ctx, steampipesdk.OpenGovernanceConfigKeyClientType)
	if err != nil {
		return nil, err
	}

	limit := int64(1)
	paginator, err := k.NewZonePaginator(essdk.BuildFilter(ctx, d.QueryContext, getZoneFilters, integrationId, encodedResourceCollectionFilters, clientType), &limit)
	if err != nil {
		return nil, err
	}

	for paginator.HasNext() {
		page, err := paginator.NextPage(ctx)
		if err != nil {
			return nil, err
		}

		for _, v := range page {
			return v, nil
		}
	}

	err = paginator.Close(ctx)
	if err != nil {
		return nil, err
	}

	return nil, nil
}

// ==========================  END: Zone =============================
